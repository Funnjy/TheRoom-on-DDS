/**
 * File generated by the ThingML IDE
 * /!\Do not edit this file/!\
 * In case of a bug in the generated code,
 * please submit an issue on our GitHub
 **/

package org.thingml.generated;

import org.thingml.java.*;
import org.thingml.java.ext.*;

import org.thingml.generated.api.*;
import org.thingml.generated.messages.*;

import java.util.*;

/**
 * Definition for type : TimerJava
 **/
public class TimerJava extends Component implements ITimerJava_timer {

private List<AttributeListener> attListener = new ArrayList<AttributeListener>();
public void addAttributeListener(AttributeListener listener){
this.attListener.add(listener);
}

public void removeAttributeListener(AttributeListener listener){
this.attListener.remove(listener);
}

private boolean debug = false;
public boolean isDebug() {return debug;}
public void setDebug(boolean debug) {this.debug = debug;}
@Override
public String toString() {
String result = "instance " + getName() + "\n";
result += "\ttimer = " + TimerJava_timer_var;
result += "";
return result;
}

private Collection<ITimerJava_timerClient> timer_clients = Collections.synchronizedCollection(new LinkedList<ITimerJava_timerClient>());
public synchronized void registerOnTimer(ITimerJava_timerClient client){
timer_clients.add(client);
}

public synchronized void unregisterFromTimer(ITimerJava_timerClient client){
timer_clients.remove(client);
}

@Override
public synchronized void timer_start_via_timer(short TimerMsgs_timer_start_delay_var){
receive(timer_startType.instantiate(TimerMsgs_timer_start_delay_var), timer_port);
}

@Override
public synchronized void timer_cancel_via_timer(){
receive(timer_cancelType.instantiate(), timer_port);
}

private void sendTimer_timeout_via_timer(){
//ThingML send
timer_port.send(timer_timeoutType.instantiate());
//send to other clients
for(ITimerJava_timerClient client : timer_clients){
client.timer_timeout_from_timer();
}}

//Attributes
private Thread TimerJava_timer_var;
private Thread debug_TimerJava_timer_var;
//Ports
private Port timer_port;
//Message types
protected final Timer_startMessageType timer_startType = new Timer_startMessageType();
public Timer_startMessageType getTimer_startType(){
return timer_startType;
}

protected final Timer_cancelMessageType timer_cancelType = new Timer_cancelMessageType();
public Timer_cancelMessageType getTimer_cancelType(){
return timer_cancelType;
}

protected final Timer_timeoutMessageType timer_timeoutType = new Timer_timeoutMessageType();
public Timer_timeoutMessageType getTimer_timeoutType(){
return timer_timeoutType;
}

//CEP Streams
//Empty Constructor
public TimerJava() {
super();
}

//Constructor (all attributes)
public TimerJava(String name, final Thread TimerJava_timer_var) {
super(name);
this.TimerJava_timer_var = TimerJava_timer_var;
}

//Getters and Setters for non readonly/final attributes
public Thread getTimerJava_timer_var() {
return TimerJava_timer_var;
}

public void setTimerJava_timer_var(Thread TimerJava_timer_var) {
this.TimerJava_timer_var = TimerJava_timer_var;
}

//Getters for Ports
public Port getTimer_port() {
return timer_port;
}
private CompositeState buildTimerJava_SoftTimer(){
final List<AtomicState> states_TimerJava_SoftTimer = new ArrayList<AtomicState>();
final AtomicState state_TimerJava_SoftTimer_default = new AtomicState("default")
;
states_TimerJava_SoftTimer.add(state_TimerJava_SoftTimer_default);
final List<Region> regions_TimerJava_SoftTimer = new ArrayList<Region>();
final List<Handler> transitions_TimerJava_SoftTimer = new ArrayList<Handler>();
transitions_TimerJava_SoftTimer.add(new InternalTransition("1335999952",timer_startType, timer_port, state_TimerJava_SoftTimer_default){
@Override
public boolean doCheck(final Event e) {
final Timer_startMessageType.Timer_startMessage timer_start = (Timer_startMessageType.Timer_startMessage) e;
return timer_start.delay > 0;
}

@Override
public void doExecute(final Event e) {
final Timer_startMessageType.Timer_startMessage timer_start = (Timer_startMessageType.Timer_startMessage) e;
startTimer((short) (timer_start.delay));
}

});
transitions_TimerJava_SoftTimer.add(new InternalTransition("cancel",timer_cancelType, timer_port, state_TimerJava_SoftTimer_default){
@Override
public void doExecute(final Event e) {
cancel();
}

});
final CompositeState state_TimerJava_SoftTimer = new CompositeState("SoftTimer", states_TimerJava_SoftTimer, state_TimerJava_SoftTimer_default, transitions_TimerJava_SoftTimer, regions_TimerJava_SoftTimer, false);
return state_TimerJava_SoftTimer;
}

public Component buildBehavior(String session, Component root) {
if (root == null) {
//Init ports
timer_port = new Port(PortType.PROVIDED, "timer", this);
} else {
timer_port = ((TimerJava)root).timer_port;
}
createCepStreams();if (session == null){
//Init state machine
behavior = buildTimerJava_SoftTimer();
}
return this;
}

private void startTimer(final short TimerJava_startTimer_delay_var) {
cancel();
Thread t = new Thread(){
               	public void run() {
               	try {
               	sleep(TimerJava_startTimer_delay_var);
sendTimer_timeout_via_timer();
} catch (InterruptedException ex) {
            	//timer canceled, do nothing and just terminate this thread
			}  catch (Exception ex) {
               ex.printStackTrace();
               //looking at Javas Thread API, can only happen if delay if negative, but that is checked in the guard in the statemachine. Double precaution
            } finally {
            	yield();
                interrupt();
TimerJava_timer_var = (Thread) (null);
}
                                                                   
    		}
            };
TimerJava_timer_var = (Thread) (t);
getTimerJava_timer_var().start();
}
private void cancel() {
if( !((getTimerJava_timer_var() == null))) {
try {
getTimerJava_timer_var().interrupt();
}  catch (Exception ex) {
                    ex.printStackTrace();//indicates a problem that is not part of the expected behavior.
             }

}
}
}
